%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}



\title{Poppy Documentation}
\date{Jul 24, 2018}
\release{1.0.0}
\author{Alvin Wan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Poppy 介绍}
\label{\detokenize{introduction:poppy}}\label{\detokenize{introduction::doc}}
Poppy 是Alvin的技术文档中心，Alvin平时会将自己遇到的一些技术上的内容记录在这里，从2018年7月23日开始记录。

如果你愿意帮助Alvin完善这个文档，可以提交pull request到该项目的github地址:\sphinxurl{https://github.com/AlvinWanCN/poppy}

\noindent\sphinxincludegraphics{{etlucency}.png}


\chapter{用户管理}
\label{\detokenize{user_management/readme:id1}}\label{\detokenize{user_management/readme::doc}}

\section{linux用户管理}
\label{\detokenize{user_management/user:linux}}\label{\detokenize{user_management/user::doc}}

\subsection{新增用户}
\label{\detokenize{user_management/user:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{useradd} \PYG{n}{alvin}
\end{sphinxVerbatim}

-u 指定uid

-g 指定主属组id

-G 指定付属组id

-d 指定home目录

-s 指定shell

-c 备注

-M 不创建home目录

-N 不创建组


\section{ldap service}
\label{\detokenize{user_management/ldap:ldap-service}}\label{\detokenize{user_management/ldap::doc}}

\subsection{Introduction}
\label{\detokenize{user_management/ldap:introduction}}
ldap 是轻量级目录管理访问协议。


\chapter{软件管理}
\label{\detokenize{software_manage/readme:id1}}\label{\detokenize{software_manage/readme::doc}}

\section{rpm}
\label{\detokenize{software_manage/rpm:rpm}}\label{\detokenize{software_manage/rpm::doc}}

\section{yum}
\label{\detokenize{software_manage/yum/readme:yum}}\label{\detokenize{software_manage/yum/readme::doc}}
yum的全称是Yellowdog Updater Modified


\subsection{搭建同步官方的yum源服务器}
\label{\detokenize{software_manage/yum/yum_official_sync:yum}}\label{\detokenize{software_manage/yum/yum_official_sync::doc}}

\subsubsection{准备篇：}
\label{\detokenize{software_manage/yum/yum_official_sync:id1}}

\paragraph{安装http服务器}
\label{\detokenize{software_manage/yum/yum_official_sync:http}}
这里使用Nginx服务器提供http服务

关于Nginx服务器搭建，参考：CentOS安装配置LNMP服务器（Nginx+PHP+MySQL）

\sphinxurl{http://www.osyunwei.com/archives/5910.html}


\paragraph{系统约定}
\label{\detokenize{software_manage/yum/yum_official_sync:id2}}
Nginx站点根目录:/www/share

服务器执行脚本文件存放目录:/home/crontab

三、开始Nginx目录浏览功能

\#编辑nginx配置文件，添加以下内容：

autoindex on; \#开启nginx目录浏览功能

autoindex\_exact\_size off; \#文件大小从KB开始显示

autoindex\_localtime on; \#显示文件修改时间为服务器本地时间

service nginx reload \#重新加载配置


\subsubsection{安装篇：}
\label{\detokenize{software_manage/yum/yum_official_sync:id3}}

\paragraph{安装环境}
\label{\detokenize{software_manage/yum/yum_official_sync:id4}}
系统版本： centos7.4
Hostname: dc.alv.pub


\paragraph{创建镜像文件存放目录}
\label{\detokenize{software_manage/yum/yum_official_sync:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkdir} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{/}\PYG{n}{www}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{centos} \PYG{c+c1}{\PYGZsh{}CentOS官方标准源}

\PYG{n}{mkdir} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{/}\PYG{n}{www}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{repoforge} \PYG{c+c1}{\PYGZsh{}第三方rpmforge源}

\PYG{n}{mkdir} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{/}\PYG{n}{www}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}\PYG{n}{epel} \PYG{c+c1}{\PYGZsh{}第三方epel源}
\end{sphinxVerbatim}

说明：这里创建三个文件夹，分别存放CentOS官方标准源、第三方的rpmforge源和epel源


\paragraph{确定以上三个yum源上游源的同步镜像地址}
\label{\detokenize{software_manage/yum/yum_official_sync:id6}}
1、CentOS官方标准源：rsync://rsync.mirrors.ustc.edu.cn/centos/

2、rpmforge源：rsync://rsync.mirrors.ispros.com.bd/repoforge/

3、epel源：rsync://rsync.mirrors.ustc.edu.cn/epel/

备注：上游yum源必须要支持rsync协议，否则不能使用rsync进行同步。

参考：

CentOS官方标准源：

rsync://mirrors.kernel.org/centos

rpmforge源：

\sphinxurl{http://apt.sw.be/}

rsync://ftp-stud.fht-esslingen.de/dag

epel源：

\sphinxurl{http://mirrors.fedoraproject.org/publiclist/EPEL/}

rsync://mirrors.kernel.org/fedora-epel


\paragraph{创建以上三个yum源同步脚本，并且设定脚本自动执行}
\label{\detokenize{software_manage/yum/yum_official_sync:id7}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir \PYGZhy{}p /home/crontab \PYGZsh{}创建目录

vi /home/crontab/yum\PYGZus{}rsync.sh \PYGZsh{}添加以下代码

\PYGZsh{}!/bin/sh

/usr/bin/rsync \PYGZhy{}avrt rsync://rsync.mirrors.ustc.edu.cn/centos/ \PYGZhy{}\PYGZhy{}exclude\PYGZhy{}from=/www/share/exclude\PYGZus{}centos.list /www/share/centos/

/usr/bin/rsync \PYGZhy{}avrt rsync://ftp\PYGZhy{}stud.fht\PYGZhy{}esslingen.de/dag/ \PYGZhy{}\PYGZhy{}exclude\PYGZhy{}from=/www/share/exclude\PYGZus{}repoforge.list /www/share/repoforge/

/usr/bin/rsync \PYGZhy{}avrt rsync://rsync.mirrors.ustc.edu.cn/epel/ \PYGZhy{}\PYGZhy{}exclude\PYGZhy{}from=/www/share/exclude\PYGZus{}epel.list /www/share/epel/

:wq! \PYGZsh{}保存退出

chmod +x /home/crontab/yum\PYGZus{}rsync.sh \PYGZsh{}添加脚本执行权限
\end{sphinxVerbatim}

查看目录列表

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rsync} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{list}\PYG{o}{\PYGZhy{}}\PYG{n}{only}  \PYG{n}{rsync}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{rsync}\PYG{o}{.}\PYG{n}{mirrors}\PYG{o}{.}\PYG{n}{ustc}\PYG{o}{.}\PYG{n}{edu}\PYG{o}{.}\PYG{n}{cn}\PYG{o}{/}\PYG{n}{centos}\PYG{o}{/}
\end{sphinxVerbatim}

备注：运行此脚本前，先要创建好同步目录及不需要同步的目录列表文件

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{/}\PYG{n}{www}\PYG{o}{/}\PYG{n}{share}\PYG{o}{/}  \PYG{c+c1}{\PYGZsh{}进入目录}

\PYG{n}{touch} \PYG{n}{exclude\PYGZus{}centos}\PYG{o}{.}\PYG{n}{list}   \PYG{c+c1}{\PYGZsh{}创建文件}

\PYG{n}{touch} \PYG{n}{exclude\PYGZus{}repoforge}\PYG{o}{.}\PYG{n}{list}   \PYG{c+c1}{\PYGZsh{}创建文件}

\PYG{n}{touch} \PYG{n}{exclude\PYGZus{}epel}\PYG{o}{.}\PYG{n}{list}   \PYG{c+c1}{\PYGZsh{}创建文件}
\end{sphinxVerbatim}

把不需要同步的目录写到上面对应的文件中，每行一个目录

例如：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{echo} \PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{4/}
\PYG{l+s+s1}{4AS/}
\PYG{l+s+s1}{4ES/}
\PYG{l+s+s1}{4WS/}
\PYG{l+s+s1}{\PYGZsq{}}\PYGZgt{}exclude\PYGZus{}epel.list
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
echo\PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{/centos/7.5.1804/isos/}
\PYG{l+s+s1}{/centos/7/isos/}
\PYG{l+s+s1}{/centos/6/isos/}
\PYG{l+s+s1}{/centos/6.9/isos/}
\PYG{l+s+s1}{\PYGZsq{}}\PYGZgt{}exclude\PYGZus{}centos.list
\end{sphinxVerbatim}


\paragraph{添加脚本定时执行任务}
\label{\detokenize{software_manage/yum/yum_official_sync:id8}}
vi /etc/crontab  \#在最后一行添加以下代码

0 1 * * * root /home/crontab/yum\_rsync.sh \#设置每天凌晨1点整开始执行脚本

:wq! \#保存退出

service crond restart \#重启


\subsubsection{测试篇：}
\label{\detokenize{software_manage/yum/yum_official_sync:id9}}

\paragraph{安装rsync同步软件}
\label{\detokenize{software_manage/yum/yum_official_sync:rsync}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
yum install rsync xinetd \PYGZsh{}安装

vi /etc/xinetd.d/rsync \PYGZsh{}编辑配置文件，设置开机启动rsync

disable = no \PYGZsh{}修改为

/etc/init.d/xinetd start \PYGZsh{}启动（CentOS中是以xinetd 来管理Rsync服务的）

:wq! \PYGZsh{}保存退出
\end{sphinxVerbatim}


\paragraph{执行同步脚本}
\label{\detokenize{software_manage/yum/yum_official_sync:id10}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sh} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{crontab}\PYG{o}{/}\PYG{n}{yum\PYGZus{}rsync}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

注意：等待脚本执行完毕，首次同步，耗费的时间比较长！


\paragraph{根据不同版本创建三个yum源的repo配置文件}
\label{\detokenize{software_manage/yum/yum_official_sync:yumrepo}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{yum}\PYG{o}{.}\PYG{n}{repos}\PYG{o}{.}\PYG{n}{d}\PYG{o}{/} \PYG{c+c1}{\PYGZsh{}进入目录}

\PYG{n}{mv} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{yum}\PYG{o}{.}\PYG{n}{repos}\PYG{o}{.}\PYG{n}{d}\PYG{o}{/}\PYG{n}{CentOS}\PYG{o}{\PYGZhy{}}\PYG{n}{Base}\PYG{o}{.}\PYG{n}{repo} \PYG{n}{CentOS}\PYG{o}{\PYGZhy{}}\PYG{n}{Base}\PYG{o}{.}\PYG{n}{repo}\PYG{o}{\PYGZhy{}}\PYG{n}{bak}
\end{sphinxVerbatim}


\subparagraph{1、CentOS官方标准源：}
\label{\detokenize{software_manage/yum/yum_official_sync:centos}}

\subparagraph{CentOS 5.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:centos-5-x}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/CentOS\PYGZhy{}Base.repo \PYGZsh{}添加以下代码
\PYGZsh{} CentOS\PYGZhy{}Base.repo
\PYGZsh{}
\PYGZsh{} The mirror system uses the connecting IP address of the client and the
\PYGZsh{} update status of each mirror to pick mirrors that are updated to and
\PYGZsh{} geographically close to the client. You should use this for CentOS updates
\PYGZsh{} unless you are manually picking other mirrors.
\PYGZsh{}
\PYGZsh{} If the mirrorlist= does not work for you, as a fall back you can try the
\PYGZsh{} remarked out baseurl= line instead.

[base]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Base \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/os/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=os
gpgcheck=1
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}5
\PYGZsh{}released updates
[updates]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Updates \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/updates/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=updates
gpgcheck=1
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}5
\PYGZsh{}packages used/produced in the build but not released
[addons]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Addons \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/addons/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=addons
gpgcheck=1
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}5
\PYGZsh{}additional packages that may be useful
[extras]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Extras \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/extras/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=extras
gpgcheck=1
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}5
\PYGZsh{}additional packages that extend functionality of existing packages
[centosplus]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Plus \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/centosplus/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=centosplus
gpgcheck=1
enabled=0
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}5
\PYGZsh{}contrib \PYGZhy{} packages by Centos Users
[contrib]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Contrib \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/contrib/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=contrib
gpgcheck=1
enabled=0
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}5
:wq! \PYGZsh{}保存退出
\end{sphinxVerbatim}


\subparagraph{CentOS 6.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:centos-6-x}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/CentOS\PYGZhy{}Base.repo \PYGZsh{}添加以下代码
\PYGZsh{} CentOS\PYGZhy{}Base.repo
\PYGZsh{}
\PYGZsh{} The mirror system uses the connecting IP address of the client and the
\PYGZsh{} update status of each mirror to pick mirrors that are updated to and
\PYGZsh{} geographically close to the client. You should use this for CentOS updates
\PYGZsh{} unless you are manually picking other mirrors.
\PYGZsh{}
\PYGZsh{} If the mirrorlist= does not work for you, as a fall back you can try the
\PYGZsh{} remarked out baseurl= line instead.
\PYGZsh{}
\PYGZsh{}
[base]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Base \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/os/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=os
gpgcheck=1
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}6
\PYGZsh{}released updates
[updates]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Updates \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/updates/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=updates
gpgcheck=1
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}6
\PYGZsh{}additional packages that may be useful
[extras]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Extras \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/extras/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=extras
gpgcheck=1
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}6
\PYGZsh{}additional packages that extend functionality of existing packages
[centosplus]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Plus \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/centosplus/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=centosplus
gpgcheck=1
enabled=0
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}6
\PYGZsh{}contrib \PYGZhy{} packages by Centos Users
[contrib]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Contrib \PYGZhy{} huanqiu.com
baseurl=http://dc.alv.pub/centos/\PYGZdl{}releasever/contrib/\PYGZdl{}basearch/
\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=contrib
gpgcheck=1
enabled=0
gpgkey=http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}6
:wq! \PYGZsh{}保存退出
\end{sphinxVerbatim}


\subparagraph{CentOS 7.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:centos-7-x}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/CentOS\PYGZhy{}Base.repo \PYG{c+c1}{\PYGZsh{}添加以下代码}
\PYG{c+c1}{\PYGZsh{} CentOS\PYGZhy{}Base.repo}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} The mirror system uses the connecting IP address of the client and the}
\PYG{c+c1}{\PYGZsh{} update status of each mirror to pick mirrors that are updated to and}
\PYG{c+c1}{\PYGZsh{} geographically close to the client. You should use this for CentOS updates}
\PYG{c+c1}{\PYGZsh{} unless you are manually picking other mirrors.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} If the mirrorlist= does not work for you, as a fall back you can try the}
\PYG{c+c1}{\PYGZsh{} remarked out baseurl= line instead.}
\PYG{c+c1}{\PYGZsh{}}

\PYG{o}{[}base\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}CentOS\PYGZhy{}\PYG{n+nv}{\PYGZdl{}releasever} \PYGZhy{} Base
\PYG{c+c1}{\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=os}
\PYG{n+nv}{baseurl}\PYG{o}{=}http://dc.alv.pub/centos/\PYG{n+nv}{\PYGZdl{}releasever}/os/\PYG{n+nv}{\PYGZdl{}basearch}/
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7

\PYG{c+c1}{\PYGZsh{}released updates}
\PYG{o}{[}updates\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}CentOS\PYGZhy{}\PYG{n+nv}{\PYGZdl{}releasever} \PYGZhy{} Updates
\PYG{c+c1}{\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=updates}
\PYG{n+nv}{baseurl}\PYG{o}{=}http://dc.alv.pub/centos/\PYG{n+nv}{\PYGZdl{}releasever}/updates/\PYG{n+nv}{\PYGZdl{}basearch}/
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7

\PYG{c+c1}{\PYGZsh{}additional packages that may be useful}
\PYG{o}{[}extras\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}CentOS\PYGZhy{}\PYG{n+nv}{\PYGZdl{}releasever} \PYGZhy{} Extras
\PYG{c+c1}{\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=extras}
\PYG{n+nv}{baseurl}\PYG{o}{=}http://dc.alv.pub/centos/\PYG{n+nv}{\PYGZdl{}releasever}/extras/\PYG{n+nv}{\PYGZdl{}basearch}/
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7

\PYG{c+c1}{\PYGZsh{}additional packages that extend functionality of existing packages}
\PYG{o}{[}centosplus\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}CentOS\PYGZhy{}\PYG{n+nv}{\PYGZdl{}releasever} \PYGZhy{} Plus
\PYG{c+c1}{\PYGZsh{}mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=centosplus}
\PYG{n+nv}{baseurl}\PYG{o}{=}http://dc.alv.pub/centos/\PYG{n+nv}{\PYGZdl{}releasever}/centosplus/\PYG{n+nv}{\PYGZdl{}basearch}/
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{enabled}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://dc.alv.pub/centos/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7
\end{sphinxVerbatim}


\bigskip\hrule\bigskip


或者参考：\sphinxurl{https://lug.ustc.edu.cn/wiki/mirrors/help/centos}

把里面的http://mirrors.ustc.edu.cn/替换为http://dc.alv.pub/, 因为我们这台服务器的主机名和域名是dc.alv.pub


\subparagraph{2、rpmforge源：}
\label{\detokenize{software_manage/yum/yum_official_sync:rpmforge}}

\subparagraph{CentOS 5.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:id11}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/rpmforge.repo \PYGZsh{}添加以下代码
[rpmforge]
name = RHEL \PYGZdl{}releasever \PYGZhy{} RPMforge.net \PYGZhy{} dag
baseurl = http://dc.alv.pub/repoforge/redhat/el5/en/\PYGZdl{}basearch/rpmforge
enabled = 1
protect = 0
gpgkey=http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
gpgcheck = 1
[rpmforge\PYGZhy{}extras]
name = RHEL \PYGZdl{}releasever \PYGZhy{} RPMforge.net \PYGZhy{} extras
baseurl = http://dc.alv.pub/repoforge/redhat/el5/en/\PYGZdl{}basearch/extras
enabled = 0
protect = 0
gpgkey=http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
gpgcheck = 1
[rpmforge\PYGZhy{}testing]
name = RHEL \PYGZdl{}releasever \PYGZhy{} RPMforge.net \PYGZhy{} testing
baseurl = http://dc.alv.pub/repoforge/redhat/el5/en/\PYGZdl{}basearch/testing
enabled = 0
protect = 0
gpgkey=http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
gpgcheck = 1
:wq! \PYGZsh{}保存退出
\end{sphinxVerbatim}


\subparagraph{CentOS 6.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:id12}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/rpmforge.repo \PYGZsh{}添加以下代码
[rpmforge]
name = RHEL \PYGZdl{}releasever \PYGZhy{} RPMforge.net \PYGZhy{} dag
baseurl = http://dc.alv.pub/repoforge/redhat/el6/en/\PYGZdl{}basearch/rpmforge
enabled = 1
protect = 0
gpgkey=http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
gpgcheck = 1
[rpmforge\PYGZhy{}extras]
name = RHEL \PYGZdl{}releasever \PYGZhy{} RPMforge.net \PYGZhy{} extras
baseurl = http://dc.alv.pub/repoforge/redhat/el6/en/\PYGZdl{}basearch/extras
enabled = 0
protect = 0
gpgkey=http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
gpgcheck = 1
[rpmforge\PYGZhy{}testing]
name = RHEL \PYGZdl{}releasever \PYGZhy{} RPMforge.net \PYGZhy{} testing
baseurl = http://dc.alv.pub/repoforge/redhat/el6/en/\PYGZdl{}basearch/testing
enabled = 0
protect = 0
gpgkey=http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
gpgcheck = 1
:wq! \PYGZsh{}保存退出
\end{sphinxVerbatim}


\subparagraph{CentOS 7.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:id13}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/rpmforge.repo \PYG{c+c1}{\PYGZsh{}添加以下代码}

\PYG{o}{[}rpmforge\PYG{o}{]}
\PYG{n+nv}{name} \PYG{o}{=} RHEL \PYG{n+nv}{\PYGZdl{}releasever} \PYGZhy{} RPMforge.net \PYGZhy{} dag
\PYG{n+nv}{baseurl} \PYG{o}{=} http://dc.alv.pub/repoforge/redhat/el7/en/\PYG{n+nv}{\PYGZdl{}basearch}/rpmforge
\PYG{n+nv}{enabled} \PYG{o}{=} \PYG{l+m}{1}
\PYG{n+nv}{protect} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
\PYG{n+nv}{gpgcheck} \PYG{o}{=} \PYG{l+m}{1}

\PYG{o}{[}rpmforge\PYGZhy{}extras\PYG{o}{]}
\PYG{n+nv}{name} \PYG{o}{=} RHEL \PYG{n+nv}{\PYGZdl{}releasever} \PYGZhy{} RPMforge.net \PYGZhy{} extras
\PYG{n+nv}{baseurl} \PYG{o}{=} http://dc.alv.pub/repoforge/redhat/el7/en/\PYG{n+nv}{\PYGZdl{}basearch}/extras
\PYG{n+nv}{enabled} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{protect} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
\PYG{n+nv}{gpgcheck} \PYG{o}{=} \PYG{l+m}{1}

\PYG{o}{[}rpmforge\PYGZhy{}testing\PYG{o}{]}
\PYG{n+nv}{name} \PYG{o}{=} RHEL \PYG{n+nv}{\PYGZdl{}releasever} \PYGZhy{} RPMforge.net \PYGZhy{} testing
\PYG{n+nv}{baseurl} \PYG{o}{=} http://dc.alv.pub/repoforge/redhat/el7/en/\PYG{n+nv}{\PYGZdl{}basearch}/testing
\PYG{n+nv}{enabled} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{protect} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{gpgkey}\PYG{o}{=}http://dc.alv.pub/repoforge/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}rpmforge
\PYG{n+nv}{gpgcheck} \PYG{o}{=} \PYG{l+m}{1}
\end{sphinxVerbatim}


\subparagraph{3、epel源：}
\label{\detokenize{software_manage/yum/yum_official_sync:epel}}

\subparagraph{CentOS 5.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:id14}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/epel.repo \PYGZsh{}添加以下代码
[epel]
name=Extra Packages for Enterprise Linux 5 \PYGZhy{} \PYGZdl{}basearch
baseurl=http://dc.alv.pub/epel/5/\PYGZdl{}basearch
failovermethod=priority
enabled=1
gpgcheck=1
gpgkey =http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}5
[epel\PYGZhy{}debuginfo]
name=Extra Packages for Enterprise Linux 5 \PYGZhy{} \PYGZdl{}basearch \PYGZhy{} Debug
baseurl=http://dc.alv.pub/epel/5/\PYGZdl{}basearch/debug
failovermethod=priority
enabled=0
gpgkey =http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}5
gpgcheck=1
[epel\PYGZhy{}source]
name=Extra Packages for Enterprise Linux 5 \PYGZhy{} \PYGZdl{}basearch \PYGZhy{} Source
baseurl=http://dc.alv.pub/epel/5/SRPMS
failovermethod=priority
enabled=0
gpgkey =http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}5
gpgcheck=1
:wq! \PYGZsh{}保存退出
\end{sphinxVerbatim}


\subparagraph{CentOS 6.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:id15}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/epel.repo \PYGZsh{}添加以下代码
[epel]
name=Extra Packages for Enterprise Linux 6 \PYGZhy{} \PYGZdl{}basearch
baseurl=http://dc.alv.pub/epel/6/\PYGZdl{}basearch
failovermethod=priority
enabled=1
gpgcheck=1
gpgkey =http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}6
[epel\PYGZhy{}debuginfo]
name=Extra Packages for Enterprise Linux 6 \PYGZhy{} \PYGZdl{}basearch \PYGZhy{} Debug
baseurl=http://dc.alv.pub/epel/6/\PYGZdl{}basearch/debug
failovermethod=priority
enabled=0
gpgkey =http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}6
gpgcheck=1
[epel\PYGZhy{}source]
name=Extra Packages for Enterprise Linux 6 \PYGZhy{} \PYGZdl{}basearch \PYGZhy{} Source
baseurl=http://dc.alv.pub/epel/6/SRPMS
failovermethod=priority
enabled=0
gpgkey =http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}6
gpgcheck=1
:wq! \PYGZsh{}保存退出
\end{sphinxVerbatim}


\subparagraph{CentOS 7.x系列：}
\label{\detokenize{software_manage/yum/yum_official_sync:id16}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
vi /etc/yum.repos.d/epel.repo \PYG{c+c1}{\PYGZsh{}添加以下代码}
\PYG{o}{[}epel\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}Extra Packages \PYG{k}{for} Enterprise Linux \PYG{l+m}{7} \PYGZhy{} \PYG{n+nv}{\PYGZdl{}basearch}
\PYG{n+nv}{baseurl}\PYG{o}{=}http://dc.alv.pub/epel/beta/7/\PYG{n+nv}{\PYGZdl{}basearch}
\PYG{n+nv}{failovermethod}\PYG{o}{=}priority
\PYG{n+nv}{enabled}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{1}
\PYG{n+nv}{gpgkey} \PYG{o}{=}http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}7

\PYG{o}{[}epel\PYGZhy{}debuginfo\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}Extra Packages \PYG{k}{for} Enterprise Linux \PYG{l+m}{7} \PYGZhy{} \PYG{n+nv}{\PYGZdl{}basearch} \PYGZhy{} Debug
\PYG{n+nv}{baseurl}\PYG{o}{=}http://dc.alv.pub/epel/beta/7/\PYG{n+nv}{\PYGZdl{}basearch}/debug
\PYG{n+nv}{failovermethod}\PYG{o}{=}priority
\PYG{n+nv}{enabled}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{gpgkey} \PYG{o}{=}http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}7
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{1}

\PYG{o}{[}epel\PYGZhy{}source\PYG{o}{]}
\PYG{n+nv}{name}\PYG{o}{=}Extra Packages \PYG{k}{for} Enterprise Linux \PYG{l+m}{7} \PYGZhy{} \PYG{n+nv}{\PYGZdl{}basearch} \PYGZhy{} Source
\PYG{n+nv}{baseurl}\PYG{o}{=}http://dc.alv.pub/epel/beta/7/SRPMS
\PYG{n+nv}{failovermethod}\PYG{o}{=}priority
\PYG{n+nv}{enabled}\PYG{o}{=}\PYG{l+m}{0}
\PYG{n+nv}{gpgkey} \PYG{o}{=}http://dc.alv.pub/epel/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}EPEL\PYGZhy{}7
\PYG{n+nv}{gpgcheck}\PYG{o}{=}\PYG{l+m}{1}
:wq! \PYG{c+c1}{\PYGZsh{}保存退出}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\paragraph{测试yum源是否配置正确}
\label{\detokenize{software_manage/yum/yum_official_sync:id17}}
我们当前系统是centos7.4，所以按照上面描述的7的yum repo配置去编写repo文件，然后开始以下操作。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{clean} \PYG{n+nb}{all} \PYG{c+c1}{\PYGZsh{}清除当前yum缓存}
\PYG{n}{yum} \PYG{n}{makecache} \PYG{c+c1}{\PYGZsh{}缓存yum源中的软件包信息}
\PYG{n}{yum} \PYG{n}{repolist} \PYG{c+c1}{\PYGZsh{}列出yum源中可用的软件包}
\end{sphinxVerbatim}

2、使用yum命令安装软件

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{install} \PYG{n}{php} \PYG{c+c1}{\PYGZsh{}测试CentOS官方标准源}
\PYG{n}{yum} \PYG{n}{install} \PYG{n}{htop} \PYG{c+c1}{\PYGZsh{}测试rpmforge源}
\PYG{n}{yum} \PYG{n}{install} \PYG{n}{nginx} \PYG{c+c1}{\PYGZsh{}测试epel源}
\end{sphinxVerbatim}

至此，搭建CentOS在线yum源镜像服务器完成！


\subsection{使用网络yum}
\label{\detokenize{software_manage/yum/yum_http:yum}}\label{\detokenize{software_manage/yum/yum_http::doc}}
默认情况下当我们安装好centos系统后，就会存在一些已经添加的官方网络yum源。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
echo\PYGZdq{}
\PYGZsh{} CentOS\PYGZhy{}Base.repo
\PYGZsh{}
\PYGZsh{} The mirror system uses the connecting IP address of the client and the
\PYGZsh{} update status of each mirror to pick mirrors that are updated to and
\PYGZsh{} geographically close to the client.  You should use this for CentOS updates
\PYGZsh{} unless you are manually picking other mirrors.
\PYGZsh{}
\PYGZsh{} If the mirrorlist= does not work for you, as a fall back you can try the
\PYGZsh{} remarked out baseurl= line instead.
\PYGZsh{}
\PYGZsh{}

[base]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Base
mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=os\PYGZam{}infra=\PYGZdl{}infra
\PYGZsh{}baseurl=http://mirror.centos.org/centos/\PYGZdl{}releasever/os/\PYGZdl{}basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm\PYGZhy{}gpg/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7

\PYGZsh{}released updates
[updates]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Updates
mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=updates\PYGZam{}infra=\PYGZdl{}infra
\PYGZsh{}baseurl=http://mirror.centos.org/centos/\PYGZdl{}releasever/updates/\PYGZdl{}basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm\PYGZhy{}gpg/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7

\PYGZsh{}additional packages that may be useful
[extras]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Extras
mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=extras\PYGZam{}infra=\PYGZdl{}infra
\PYGZsh{}baseurl=http://mirror.centos.org/centos/\PYGZdl{}releasever/extras/\PYGZdl{}basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm\PYGZhy{}gpg/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7

\PYGZsh{}additional packages that extend functionality of existing packages
[centosplus]
name=CentOS\PYGZhy{}\PYGZdl{}releasever \PYGZhy{} Plus
mirrorlist=http://mirrorlist.centos.org/?release=\PYGZdl{}releasever\PYGZam{}arch=\PYGZdl{}basearch\PYGZam{}repo=centosplus\PYGZam{}infra=\PYGZdl{}infra
\PYGZsh{}baseurl=http://mirror.centos.org/centos/\PYGZdl{}releasever/centosplus/\PYGZdl{}basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm\PYGZhy{}gpg/RPM\PYGZhy{}GPG\PYGZhy{}KEY\PYGZhy{}CentOS\PYGZhy{}7
\PYGZdq{} \PYGZgt{} /etc/yum.repos.d/CentOS\PYGZhy{}Base.repo
\end{sphinxVerbatim}


\subsection{使用本地yum}
\label{\detokenize{software_manage/yum/yum_iso_local:yum}}\label{\detokenize{software_manage/yum/yum_iso_local::doc}}
这篇我们讲个最简单的本地yum源。

添加光盘的步骤我们略过，本环境系统下已存在ISO镜像

本实验在centos7下进行。


\subsubsection{创建用于挂在光盘的目录}
\label{\detokenize{software_manage/yum/yum_iso_local:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mkdir} \PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{iso}
\end{sphinxVerbatim}


\subsubsection{挂在光盘到本地目录}
\label{\detokenize{software_manage/yum/yum_iso_local:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mount} \PYG{o}{/}\PYG{n}{dev}\PYG{o}{/}\PYG{n}{cdrom} \PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{iso}
\end{sphinxVerbatim}


\subsubsection{创建yum仓库}
\label{\detokenize{software_manage/yum/yum_iso_local:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}
\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}
\PYG{n}{name}\PYG{o}{=}\PYG{n}{localiso}
\PYG{n}{baseurl}\PYG{o}{=}\PYG{n}{file}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{o}{/}\PYG{n}{mnt}\PYG{o}{/}\PYG{n}{iso}
\PYG{n}{gpgcheck}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{enable}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ \PYGZgt{} /etc/yum.repos.d/local.repo}
\end{sphinxVerbatim}


\subsubsection{清空yum缓存}
\label{\detokenize{software_manage/yum/yum_iso_local:id4}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{clean} \PYG{n+nb}{all}
\end{sphinxVerbatim}


\subsubsection{查看yum源列表}
\label{\detokenize{software_manage/yum/yum_iso_local:id5}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{repolist}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{yum_local_iso}.jpg}


\chapter{系统常用服务}
\label{\detokenize{common_service/readme:id1}}\label{\detokenize{common_service/readme::doc}}

\section{systemd}
\label{\detokenize{common_service/systemd_index:systemd}}\label{\detokenize{common_service/systemd_index::doc}}
systemd service

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{common_service/systemd:id4}}{\hyperref[\detokenize{common_service/systemd:id1}]{\sphinxcrossref{需求}}}

\item {} 
\phantomsection\label{\detokenize{common_service/systemd:id5}}{\hyperref[\detokenize{common_service/systemd:id2}]{\sphinxcrossref{解决方案}}}

\item {} 
\phantomsection\label{\detokenize{common_service/systemd:id6}}{\hyperref[\detokenize{common_service/systemd:systemd}]{\sphinxcrossref{systemd简介}}}

\item {} 
\phantomsection\label{\detokenize{common_service/systemd:id7}}{\hyperref[\detokenize{common_service/systemd:id3}]{\sphinxcrossref{systemd文件示例：}}}

\item {} 
\phantomsection\label{\detokenize{common_service/systemd:id8}}{\hyperref[\detokenize{common_service/systemd:sophroth-pxe}]{\sphinxcrossref{启动 sophroth-pxe服务}}}

\end{itemize}
\end{sphinxShadowBox}


\subsection{需求}
\label{\detokenize{common_service/systemd:id1}}\label{\detokenize{common_service/systemd::doc}}
运行环境为CentOS 7系统，我们开发了一个程序，需要在开机时启动它，当程序进程crash之后，守护进程立即拉起进程。


\subsection{解决方案}
\label{\detokenize{common_service/systemd:id2}}
使用CentOS 7中的init进程systemd


\subsection{systemd简介}
\label{\detokenize{common_service/systemd:systemd}}
参考资料:\sphinxurl{https://blog.csdn.net/shuaixingi/article/details/49641721}

Linux Init \& CentOS systemd

Linux一直以来采用init进程。例如下面的命令用来启动服务：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZdl{} sudo /etc/init.d/apache2 start

或者\PYG{l+s+se}{\PYGZbs{} }\PYGZdl{} service apache2 start
\end{sphinxVerbatim}

但是init有两个缺点：
\begin{itemize}
\item {} 
1、启动时间长。Init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。（这也是CentOS5的主要特征)

\item {} 
2、启动脚本复杂。Init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这使得脚本变得很长而且复杂。

\end{itemize}

Init：
\begin{itemize}
\item {} 
Centos 5 Sys init 是启动速度最慢的，串行启动过程，无论进程相互之间有无依赖关系。

\item {} 
Centos6 Upstart init 相对启动速度快一点有所改进。有依赖的进程之间依次启动而其他与之没有依赖关系的则并行同步启动。

\item {} 
Centos7 systemd 与以上都不同。所有进程无论有无依赖关系则都是并行启动（当然很多时候进程没有真正启动而是只有一个信号或者说是标记而已，在真正利用的时候才会真正启动。）

\end{itemize}

systemd为了解决上文的问题而诞生。它的目标是，为系统的启动和管理提供一套完整的解决方案。根据linux惯例，字母d是守护进程（daemon） 的缩写。Systemd名字的含义就是 守护整个系统。Centos 7里systemd代替了init，成为了系统的第一个进程。PID为1.其他所有的进程都是它的子进程。

systemd 是 Linux 下的一款系统和服务管理器，兼容 SysV 和 LSB 的启动脚本。systemd 的特性有：支持并行化任务；同时采用 socket 式与 D-Bus 总线式激活服务；按需启动守护进程（daemon）；利用 Linux 的 cgroups 监视进程；支持快照和系统恢复；维护挂载点和自动挂载点；各服务间基于依赖关系进行精密控制。


\subsection{systemd文件示例：}
\label{\detokenize{common_service/systemd:id3}}
ExecStart后面的，就是启动该服务器时要执行的命令，可以说是单个脚本，也可以是一个命令加参数。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{echo} \PYG{l+s+s1}{\PYGZsq{}}
\PYG{l+s+s1}{[Unit]}
\PYG{l+s+s1}{Description=The Sophiroth Service}
\PYG{l+s+s1}{After=syslog.target network.target salt\PYGZhy{}master.service}

\PYG{l+s+s1}{[Service]}
\PYG{l+s+s1}{Type=simple}
\PYG{l+s+s1}{User=alvin}
\PYG{l+s+s1}{WorkingDirectory=/opt/sophiroth\PYGZhy{}pxe}
\PYG{l+s+s1}{ExecStart=/usr/bin/python2 \PYGZhy{}m CGIHTTPServer 8001}
\PYG{l+s+s1}{KillMode=process}
\PYG{l+s+s1}{Restart=on\PYGZhy{}failure}
\PYG{l+s+s1}{RestartSec=3s}

\PYG{l+s+s1}{[Install]}
\PYG{l+s+s1}{WantedBy=multi\PYGZhy{}user.target graphic.target}
\PYG{l+s+s1}{\PYGZsq{}} \PYGZgt{} /usr/lib/systemd/system/sophiroth\PYGZhy{}pxe.service
\end{sphinxVerbatim}


\subsection{启动 sophroth-pxe服务}
\label{\detokenize{common_service/systemd:sophroth-pxe}}
\fvset{hllines={, 2,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
systemctl \PYG{n+nb}{enable} sophiroth\PYGZhy{}pxe
systemctl start sophiroth\PYGZhy{}pxe
systemctl status sophiroth\PYGZhy{}pxe
lsof \PYGZhy{}i:8001
\end{sphinxVerbatim}


\chapter{网络}
\label{\detokenize{network/readme:id1}}\label{\detokenize{network/readme::doc}}

\section{dhcp}
\label{\detokenize{network/dhcp:dhcp}}\label{\detokenize{network/dhcp::doc}}

\subsection{安装dhcp服务}
\label{\detokenize{network/dhcp:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{dhcp}
\end{sphinxVerbatim}


\subsection{配置DHCP服务}
\label{\detokenize{network/dhcp:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vim} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{dhcp}\PYG{o}{/}\PYG{n}{dhcpd}\PYG{o}{.}\PYG{n}{conf}
\PYG{c+c1}{\PYGZsh{}设置DHCP于DNS服务器的动态信息更新模式。初学时完全可以不理这个选项，但是全局设置中一定要有这个选项，否则DHCP服务不能成功启动。}
\PYG{n}{ddns}\PYG{o}{\PYGZhy{}}\PYG{n}{update}\PYG{o}{\PYGZhy{}}\PYG{n}{style} \PYG{n}{interim}\PYG{p}{;}
\PYG{n}{subnet} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.0} \PYG{n}{netmask} \PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{255.0} \PYG{p}{\PYGZob{}}
    \PYG{n+nb}{range} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.200} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.254}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}分配给客户机的IP从192.168.233.100开始到192.168.233.199}
    \PYG{n}{option} \PYG{n}{routers} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.1}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}设置网关}
    \PYG{n}{default}\PYG{o}{\PYGZhy{}}\PYG{n}{lease}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{l+m+mi}{600}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}默认租约时间}
    \PYG{n+nb}{max}\PYG{o}{\PYGZhy{}}\PYG{n}{lease}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{l+m+mi}{7200}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}最大租约时间}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

为指定服务器网卡进行MAC地址与IP地址绑定，则继续在上面的配置文件下面进行如下配置

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{host} \PYG{n}{ops2} \PYG{p}{\PYGZob{}} \PYG{c+c1}{\PYGZsh{}有一个主机，叫ops2}
    \PYG{n}{hardware} \PYG{n}{ethernet} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{n}{c}\PYG{p}{:}\PYG{l+m+mi}{29}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{n}{c}\PYG{p}{:}\PYG{l+m+mi}{53}\PYG{p}{:}\PYG{l+m+mi}{48}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}MAC地址是08:...:27的网卡}
    \PYG{n}{fixed}\PYG{o}{\PYGZhy{}}\PYG{n}{address} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.235}\PYG{p}{;}    \PYG{c+c1}{\PYGZsh{}分配给它192.168.38.235的IP}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

以上是为一个网段做配置，那么如果是两个网段呢？我们进行如下配置，顺便将dhcp于dns服务器的动态信息更新关掉

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vim} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{dhcp}\PYG{o}{/}\PYG{n}{dhcpd}\PYG{o}{.}\PYG{n}{conf}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} DHCP Server Configuration file.}
\PYG{c+c1}{\PYGZsh{}   see /usr/share/doc/dhcp*/dhcpd.conf.example}
\PYG{c+c1}{\PYGZsh{}   see dhcpd.conf(5) man page}
\PYG{c+c1}{\PYGZsh{}设置DHCP于DNS服务器的动态信息更新模式。初学时完全可以不理这个选项，但是全局设置中一定要有这个选项，否则DHCP服务不能成功启动。}
\PYG{n}{ddns}\PYG{o}{\PYGZhy{}}\PYG{n}{update}\PYG{o}{\PYGZhy{}}\PYG{n}{style} \PYG{n}{none}\PYG{p}{;}
\PYG{n}{shared}\PYG{o}{\PYGZhy{}}\PYG{n}{network} \PYG{n}{alpha} \PYG{p}{\PYGZob{}}
\PYG{n}{subnet} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.0} \PYG{n}{netmask} \PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{255.0} \PYG{p}{\PYGZob{}}
    \PYG{n+nb}{range} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.100} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.200}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}分配给客户机的IP从192.168.233.100开始到192.168.233.199}
    \PYG{n}{option} \PYG{n}{domain}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{servers} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.3}\PYG{p}{;}
    \PYG{n}{option} \PYG{n}{domain}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alv.pub shenmin.com sophiroth.com}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{option} \PYG{n}{routers} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.1}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}设置网关}
    \PYG{n}{default}\PYG{o}{\PYGZhy{}}\PYG{n}{lease}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{l+m+mi}{600}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}默认租约时间}
    \PYG{n+nb}{max}\PYG{o}{\PYGZhy{}}\PYG{n}{lease}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{l+m+mi}{7200}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}最大租约时间}
\PYG{p}{\PYGZcb{}}
\PYG{n}{host} \PYG{n}{ops2} \PYG{p}{\PYGZob{}} \PYG{c+c1}{\PYGZsh{}有一个主机，叫ops2}
    \PYG{n}{hardware} \PYG{n}{ethernet} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{n}{c}\PYG{p}{:}\PYG{l+m+mi}{29}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{n}{c}\PYG{p}{:}\PYG{l+m+mi}{53}\PYG{p}{:}\PYG{l+m+mi}{48}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}MAC地址是08:...:27的网卡}
    \PYG{n}{fixed}\PYG{o}{\PYGZhy{}}\PYG{n}{address} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.235}\PYG{p}{;}    \PYG{c+c1}{\PYGZsh{}分配给它192.168.38.235的IP}
\PYG{p}{\PYGZcb{}}
\PYG{n}{host} \PYG{n}{ops1} \PYG{p}{\PYGZob{}} \PYG{c+c1}{\PYGZsh{}有一个主机，叫ops1}
    \PYG{n}{hardware} \PYG{n}{ethernet} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{n}{C}\PYG{p}{:}\PYG{l+m+mi}{29}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{n}{A}\PYG{p}{:}\PYG{l+m+mi}{81}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{n}{B}\PYG{p}{;}
    \PYG{n}{fixed}\PYG{o}{\PYGZhy{}}\PYG{n}{address} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.200}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{host} \PYG{n}{t1} \PYG{p}{\PYGZob{}} \PYG{c+c1}{\PYGZsh{}有一个主机，叫t1}
    \PYG{n}{hardware} \PYG{n}{ethernet} \PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{50}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{:}\PYG{l+m+mi}{32}\PYG{p}{:}\PYG{l+m+mi}{9}\PYG{n}{C}\PYG{p}{:}\PYG{n}{C4}\PYG{p}{;}
    \PYG{n}{fixed}\PYG{o}{\PYGZhy{}}\PYG{n}{address} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{38.86}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{subnet} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{127.0} \PYG{n}{netmask} \PYG{l+m+mf}{255.255}\PYG{o}{.}\PYG{l+m+mf}{255.0} \PYG{p}{\PYGZob{}}
    \PYG{n+nb}{range} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{127.100} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{127.200}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}分配给客户机的IP从192.168.233.100开始到192.168.233.199}
    \PYG{n}{option} \PYG{n}{domain}\PYG{o}{\PYGZhy{}}\PYG{n}{name}\PYG{o}{\PYGZhy{}}\PYG{n}{servers} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{127.3}\PYG{p}{,}\PYG{l+m+mf}{114.114}\PYG{o}{.}\PYG{l+m+mf}{114.114}\PYG{p}{;}
    \PYG{n}{option} \PYG{n}{domain}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{alv.pub shenmin.com sophiroth.com}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{option} \PYG{n}{routers} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{127.2}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}设置网关}
    \PYG{n}{default}\PYG{o}{\PYGZhy{}}\PYG{n}{lease}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{l+m+mi}{600}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}默认租约时间}
    \PYG{n+nb}{max}\PYG{o}{\PYGZhy{}}\PYG{n}{lease}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{l+m+mi}{7200}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{}最大租约时间}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{安全管理}
\label{\detokenize{security/readme:id1}}\label{\detokenize{security/readme::doc}}

\section{ugo}
\label{\detokenize{security/ugo:ugo}}\label{\detokenize{security/ugo::doc}}

\section{selinux}
\label{\detokenize{security/selinux:selinux}}\label{\detokenize{security/selinux::doc}}

\chapter{数据库}
\label{\detokenize{database/readme:id1}}\label{\detokenize{database/readme::doc}}

\section{mysql}
\label{\detokenize{database/mysql:mysql}}\label{\detokenize{database/mysql::doc}}

\subsection{安装mysql}
\label{\detokenize{database/mysql:id1}}

\subsection{配置mysql}
\label{\detokenize{database/mysql:id2}}

\subsection{查询}
\label{\detokenize{database/mysql:id3}}

\section{mongodb}
\label{\detokenize{database/mongodb:mongodb}}\label{\detokenize{database/mongodb::doc}}

\subsection{安装mongodb}
\label{\detokenize{database/mongodb:id1}}
aaa


\subsection{配置mongodb}
\label{\detokenize{database/mongodb:id2}}

\chapter{存储}
\label{\detokenize{storage/readme:id1}}\label{\detokenize{storage/readme::doc}}

\section{lvm}
\label{\detokenize{storage/lvm:lvm}}\label{\detokenize{storage/lvm::doc}}

\section{iscsi}
\label{\detokenize{storage/iscsi:iscsi}}\label{\detokenize{storage/iscsi::doc}}

\section{ceph}
\label{\detokenize{storage/ceph:ceph}}\label{\detokenize{storage/ceph::doc}}

\chapter{监控}
\label{\detokenize{monitor/readme:id1}}\label{\detokenize{monitor/readme::doc}}

\section{common\_system\_tools}
\label{\detokenize{monitor/common_system_tools:common-system-tools}}\label{\detokenize{monitor/common_system_tools::doc}}

\section{zabbix}
\label{\detokenize{monitor/zabbix:zabbix}}\label{\detokenize{monitor/zabbix::doc}}

\section{nagios}
\label{\detokenize{monitor/nagios:nagios}}\label{\detokenize{monitor/nagios::doc}}

\chapter{脚本}
\label{\detokenize{scripts/readme:id1}}\label{\detokenize{scripts/readme::doc}}

\section{shell}
\label{\detokenize{scripts/shell/readme:shell}}\label{\detokenize{scripts/shell/readme::doc}}

\subsection{awk}
\label{\detokenize{scripts/shell/awk:awk}}\label{\detokenize{scripts/shell/awk::doc}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/awk:id1}}{\hyperref[\detokenize{scripts/shell/awk:awk}]{\sphinxcrossref{awk}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/awk:id2}}{\hyperref[\detokenize{scripts/shell/awk:text}]{\sphinxcrossref{删除文件 text中第一列}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{删除文件 text中第一列}
\label{\detokenize{scripts/shell/awk:text}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
awk \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZdl{}1=\PYGZdq{}\PYGZdq{};print \PYGZdl{}0\PYGZcb{}\PYGZsq{}} text
\end{sphinxVerbatim}

打印text中的第二列

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
awk \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}print \PYGZdl{}2\PYGZcb{}\PYGZsq{}} text
\end{sphinxVerbatim}


\subsection{date}
\label{\detokenize{scripts/shell/date:date}}\label{\detokenize{scripts/shell/date::doc}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/date:id6}}{\hyperref[\detokenize{scripts/shell/date:date}]{\sphinxcrossref{date}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/date:id7}}{\hyperref[\detokenize{scripts/shell/date:id1}]{\sphinxcrossref{描述}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/date:id8}}{\hyperref[\detokenize{scripts/shell/date:id2}]{\sphinxcrossref{查看当前时间包含年月日时分秒}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/date:id9}}{\hyperref[\detokenize{scripts/shell/date:id3}]{\sphinxcrossref{指定前一天}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/date:id10}}{\hyperref[\detokenize{scripts/shell/date:id4}]{\sphinxcrossref{指定前一个月}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/date:id11}}{\hyperref[\detokenize{scripts/shell/date:id5}]{\sphinxcrossref{指定前五分钟}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{描述}
\label{\detokenize{scripts/shell/date:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
date +\PYGZpc{}s 取时间戳
1.时间命令：date
向date命令传递参数适用‘+‘（加号），在传递的参数中
\PYGZpc{}Y表示年
\PYGZpc{}m表示月
\PYGZpc{}d表示天
\PYGZpc{}H表示小时（表示的时间是00\PYGZhy{}23）
\PYGZpc{}M表示分钟
\PYGZpc{}S表示秒
\PYGZpc{}s（表示unix时间戳的秒数）
\end{sphinxVerbatim}


\subsubsection{查看当前时间包含年月日时分秒}
\label{\detokenize{scripts/shell/date:id2}}
date  +\%Y\%m\%d-\%H:\%M:\%S


\subsubsection{指定前一天}
\label{\detokenize{scripts/shell/date:id3}}
date -d ‘1 days ago’ +\%Y\%m\%d


\subsubsection{指定前一个月}
\label{\detokenize{scripts/shell/date:id4}}
date -d ‘1 month ago’ +\%Y\%m\%d


\subsubsection{指定前五分钟}
\label{\detokenize{scripts/shell/date:id5}}
date -d ‘5 minute ago’ +\%Y\%m\%d-\%H:\%M:\%S


\subsection{find}
\label{\detokenize{scripts/shell/find:find}}\label{\detokenize{scripts/shell/find::doc}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/find:id4}}{\hyperref[\detokenize{scripts/shell/find:find}]{\sphinxcrossref{find}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/find:id5}}{\hyperref[\detokenize{scripts/shell/find:id1}]{\sphinxcrossref{查看指定目录内两分钟内有修改的文件}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/find:id6}}{\hyperref[\detokenize{scripts/shell/find:id2}]{\sphinxcrossref{查看两天内有修改过的文件}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/find:id7}}{\hyperref[\detokenize{scripts/shell/find:id3}]{\sphinxcrossref{查看指定目录内命名为指定名称的文件}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/find:id8}}{\hyperref[\detokenize{scripts/shell/find:a}]{\sphinxcrossref{要忽略 a 目录：}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{查看指定目录内两分钟内有修改的文件}
\label{\detokenize{scripts/shell/find:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{find} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{log} \PYG{o}{\PYGZhy{}}\PYG{n}{cmin} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}


\subsubsection{查看两天内有修改过的文件}
\label{\detokenize{scripts/shell/find:id2}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{find} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{ctime} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}


\subsubsection{查看指定目录内命名为指定名称的文件}
\label{\detokenize{scripts/shell/find:id3}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{find} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{original}\PYG{o}{\PYGZhy{}}\PYG{n}{ks}\PYG{o}{.}\PYG{n}{cfg}
\end{sphinxVerbatim}

支持通配符,使用通配符的是要要加引号。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{find} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{log}\PYG{o}{/} \PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*.log}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\subsubsection{要忽略 a 目录：}
\label{\detokenize{scripts/shell/find:a}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{find} \PYG{o}{.} \PYG{o}{\PYGZhy{}}\PYG{n}{path} \PYG{o}{.}\PYG{o}{/}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{prune} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{o}{\PYGZhy{}}\PYG{n+nb}{type} \PYG{n}{f} \PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{s}\PYG{o}{.}\PYG{n}{txt} \PYG{o}{\PYGZhy{}}\PYG{n+nb}{print}
\end{sphinxVerbatim}


\subsection{sed （stream editor）}
\label{\detokenize{scripts/shell/sed:sed-stream-editor}}\label{\detokenize{scripts/shell/sed::doc}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/sed:id5}}{\hyperref[\detokenize{scripts/shell/sed:sed-stream-editor}]{\sphinxcrossref{sed （stream editor）}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/sed:id6}}{\hyperref[\detokenize{scripts/shell/sed:id1}]{\sphinxcrossref{将153和158行的\#替换为空。}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/sed:id7}}{\hyperref[\detokenize{scripts/shell/sed:id2}]{\sphinxcrossref{使用前面匹配到的内容}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/sed:id8}}{\hyperref[\detokenize{scripts/shell/sed:id3}]{\sphinxcrossref{替换换行符为+}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/sed:id9}}{\hyperref[\detokenize{scripts/shell/sed:id4}]{\sphinxcrossref{匹配行前或后增加指定内容}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/sed:id10}}{\hyperref[\detokenize{scripts/shell/sed:text}]{\sphinxcrossref{删除文件 text中第一列}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{将153和158行的\#替换为空。}
\label{\detokenize{scripts/shell/sed:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sed \PYGZhy{}in \PYG{l+s+s1}{\PYGZsq{}153,158s/\PYGZsh{}//\PYGZsq{}} \PYG{n+nv}{\PYGZdl{}Setfiles}
\end{sphinxVerbatim}


\subsubsection{使用前面匹配到的内容}
\label{\detokenize{scripts/shell/sed:id2}}
匹配替换时，\&会变成起那么匹配到的内容，所以在下面的例子中，我们前面匹配所有内容，然后替换为\#\&就是\#加上所有内容。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sed \PYGZhy{}in \PYG{l+s+s1}{\PYGZsq{}160,164s/.*/\PYGZsh{}\PYGZam{}/\PYGZsq{}} \PYG{n+nv}{\PYGZdl{}Setfiles}
\end{sphinxVerbatim}


\subsubsection{替换换行符为+}
\label{\detokenize{scripts/shell/sed:id3}}
这里我们将所有行合并了，将换行符替换成了+号。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sed \PYG{l+s+s1}{\PYGZsq{}:a;N;s/\PYGZbs{}n/+/g;ta\PYGZsq{}} \PYG{l+m}{1}.txt
\end{sphinxVerbatim}


\subsubsection{匹配行前或后增加指定内容}
\label{\detokenize{scripts/shell/sed:id4}}
a是append， 在匹配行后面增加一行指定内容，下面是在file文件里在匹配到aa的行的后面增加内容qqq

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sed \PYGZhy{}i /aa/a\PYG{l+s+se}{\PYGZbs{}q}qq file
\end{sphinxVerbatim}

i是insert， 在匹配行前面插入一行指定内容，下面是在file文件里在匹配到aa的行的前面增加内容qqq

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sed \PYGZhy{}i /aa/i\PYG{l+s+se}{\PYGZbs{}q}qq file
\end{sphinxVerbatim}


\subsubsection{删除文件 text中第一列}
\label{\detokenize{scripts/shell/sed:text}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sed \PYGZhy{}e \PYG{l+s+s1}{\PYGZsq{}s/[\PYGZca{} ]* //\PYGZsq{}} text
\end{sphinxVerbatim}


\subsection{sort}
\label{\detokenize{scripts/shell/sort:sort}}\label{\detokenize{scripts/shell/sort::doc}}
\begin{sphinxShadowBox}
\sphinxstyletopictitle{Contents}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/sort:id3}}{\hyperref[\detokenize{scripts/shell/sort:sort}]{\sphinxcrossref{sort}}}
\begin{itemize}
\item {} 
\phantomsection\label{\detokenize{scripts/shell/sort:id4}}{\hyperref[\detokenize{scripts/shell/sort:id1}]{\sphinxcrossref{指定第九列按照数字顺序排列}}}

\item {} 
\phantomsection\label{\detokenize{scripts/shell/sort:id5}}{\hyperref[\detokenize{scripts/shell/sort:id2}]{\sphinxcrossref{指定第九列按照数字倒序排列}}}

\end{itemize}

\end{itemize}
\end{sphinxShadowBox}


\subsubsection{指定第九列按照数字顺序排列}
\label{\detokenize{scripts/shell/sort:id1}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sort \PYGZhy{}n \PYGZhy{}k \PYG{l+m}{9} file.txt
\end{sphinxVerbatim}


\subsubsection{指定第九列按照数字倒序排列}
\label{\detokenize{scripts/shell/sort:id2}}
-r 倒叙排列，数字大的在前面。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sort \PYGZhy{}nr \PYGZhy{}k \PYG{l+m}{9} file.txt
\end{sphinxVerbatim}


\section{python}
\label{\detokenize{scripts/python:python}}\label{\detokenize{scripts/python::doc}}

\chapter{虚拟化}
\label{\detokenize{virtualization/readme:id1}}\label{\detokenize{virtualization/readme::doc}}

\section{docker}
\label{\detokenize{virtualization/docker:docker}}\label{\detokenize{virtualization/docker::doc}}

\section{kubernetes}
\label{\detokenize{virtualization/kubernetes:kubernetes}}\label{\detokenize{virtualization/kubernetes::doc}}

\section{kvm}
\label{\detokenize{virtualization/kvm:kvm}}\label{\detokenize{virtualization/kvm::doc}}

\section{openstack}
\label{\detokenize{virtualization/openstack/readme:openstack}}\label{\detokenize{virtualization/openstack/readme::doc}}

\subsection{rabbbitmq}
\label{\detokenize{virtualization/openstack/rabbitmq:rabbbitmq}}\label{\detokenize{virtualization/openstack/rabbitmq::doc}}

\chapter{高可用 \& 负载均衡}
\label{\detokenize{ha_lb/readme:id1}}\label{\detokenize{ha_lb/readme::doc}}

\section{haproxy}
\label{\detokenize{ha_lb/haproxy:haproxy}}\label{\detokenize{ha_lb/haproxy::doc}}

\section{lvs}
\label{\detokenize{ha_lb/lvs:lvs}}\label{\detokenize{ha_lb/lvs::doc}}

\section{keepalived}
\label{\detokenize{ha_lb/keepalived:keepalived}}\label{\detokenize{ha_lb/keepalived::doc}}

\chapter{web}
\label{\detokenize{web/readme:web}}\label{\detokenize{web/readme::doc}}

\section{nginx}
\label{\detokenize{web/nginx:nginx}}\label{\detokenize{web/nginx::doc}}

\section{apache}
\label{\detokenize{web/apache:apache}}\label{\detokenize{web/apache::doc}}

\section{tomcat}
\label{\detokenize{web/tomcat:tomcat}}\label{\detokenize{web/tomcat::doc}}

\chapter{rscsa}
\label{\detokenize{rhcsa/readme:rscsa}}\label{\detokenize{rhcsa/readme::doc}}

\section{重设root 密码}
\label{\detokenize{rhcsa/rhcsa_7:root}}\label{\detokenize{rhcsa/rhcsa_7::doc}}\begin{enumerate}
\item {} 
重启虚拟机 server，出现 GRUB 启动菜单时按 e 键进入编辑状态

\item {} 
找到 linux16 所在行，末尾添加 rd.break console=tty0，按 Ctrl+x 键进恢复模式

\item {} 
以可写方式挂载硬盘中的根目录，并重设root 密码：

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mount} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{remount}\PYG{p}{,}\PYG{n}{rw} \PYG{o}{/}\PYG{n}{sysroot} \PYG{c+c1}{\PYGZsh{}以可读写方式重新挂载根系}
\PYG{n}{chroot} \PYG{o}{/}\PYG{n}{sysroot}\PYG{o}{/} \PYG{c+c1}{\PYGZsh{}切换到根系统}
\PYG{n}{passwd} \PYG{n}{root} \PYG{c+c1}{\PYGZsh{}设置考试指定的root密码}
\PYG{n}{touch} \PYG{o}{/}\PYG{o}{.}\PYG{n}{autorelabel} \PYG{c+c1}{\PYGZsh{}标记下一次启动重做SELinux标签}
\PYG{n}{exit}
\PYG{n}{reboot}
\end{sphinxVerbatim}


\section{配置主机名、IP地址/掩码/默认网关/DNS 地址}
\label{\detokenize{rhcsa/rhcsa_7:ip-dns}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hostnamectl} \PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{hostname} \PYG{n}{serverX}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{com}
\end{sphinxVerbatim}


\section{修改ip地址}
\label{\detokenize{rhcsa/rhcsa_7:ip}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} nmcli conn show}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} nmcli conn modify eth0 ipv4.addresses     \PYGZsq{}172.25.0.11/24 172.25.0.254\PYGZsq{} ipv4.dns 172.25.254.254   ipv4.method manual}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} nmcli connection modify eth0 connection.autoconnect yes}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} nmcli conn up eth0 [root@server0 \PYGZti{}]\PYGZsh{} nmcli conn show eth0}
\end{sphinxVerbatim}

ping 测试


\section{确认 selinux 模式}
\label{\detokenize{rhcsa/rhcsa_7:selinux}}
请按下列要求设定系统：

SeLinux 的工作模式为 enforcing 要求系统重启后依然生效

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{}vim /etc/sysconfig/selinux}
\PYG{c+c1}{\PYGZsh{} SELINUX= can take one of these three values:}
\PYG{n}{SELINUX}\PYG{o}{=}\PYG{n}{enforcing} \PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} setenforce 1}
\end{sphinxVerbatim}


\section{配置yum}
\label{\detokenize{rhcsa/rhcsa_7:yum}}
YUM 的软件库源为 \sphinxurl{http://rhgls.domainX.example.com/pub/x86\_64/Server}.将此配置为 您的系统的默认软件仓库

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rpm} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{k+kn}{import} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{pki}\PYG{o}{/}\PYG{n}{rpm}\PYG{o}{\PYGZhy{}}\PYG{n}{gpg}\PYG{o}{/}\PYG{n}{RPM}\PYG{o}{\PYGZhy{}}\PYG{n}{GPG}\PYG{o}{\PYGZhy{}}\PYG{n}{KEY}\PYG{o}{\PYGZhy{}}\PYG{n}{redhat}\PYG{o}{\PYGZhy{}}\PYG{o}{*}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} cd /etc/yum.repos.d/}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{n}{yum}\PYG{o}{.}\PYG{n}{repos}\PYG{o}{.}\PYG{n}{d}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} vim base.repo}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{n}{yum}\PYG{o}{.}\PYG{n}{repos}\PYG{o}{.}\PYG{n}{d}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} cat base.repo}
\PYG{p}{[}\PYG{n}{base}\PYG{p}{]} \PYG{n}{name}\PYG{o}{=}\PYG{n}{base}
\PYG{n}{baseurl}\PYG{o}{=}\PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{classroom}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{content}\PYG{o}{/}\PYG{n}{rhel7}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{n}{x86\PYGZus{}64}\PYG{o}{/}\PYG{n}{dvd} \PYG{n}{enabled}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{n}{yum}\PYG{o}{.}\PYG{n}{repos}\PYG{o}{.}\PYG{n}{d}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} yum repolist}
\end{sphinxVerbatim}


\section{调整逻辑卷的大小}
\label{\detokenize{rhcsa/rhcsa_7:id1}}
请按照以下要求调整本地逻辑卷 lvm1 的容量：调整后的逻辑卷及文件系统大小为 770MiB 调整后确保文件系统中已存在的内容不能被破坏调整后的容量可能出现误差，只要在 730MiB - 805MiB 之间都是允许的调整后，保证其挂载目录不改变，文件系统完成

考试时候系统中只有一块硬盘 vda，而且已经使用三个分区 vda1 vda2 vda3。

如果卷组需要扩容，将剩余所有空间划分给第四个分区，第四个分区类型是扩展分区

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
lvm 信息
[root@server0 \PYGZti{}]\PYGZsh{} pvs
PV  VG      Fmt     Attr PSize      PFree
/dev/vdb1   vg1     lvm2 a\PYGZhy{}\PYGZhy{}        508.00m 252.00m
[root@server0 \PYGZti{}]\PYGZsh{} vgs
VG  \PYGZsh{}PV \PYGZsh{}LV \PYGZsh{}SN Attr        VSize   VFree vg1       1       1       0 wz\PYGZhy{}\PYGZhy{}n\PYGZhy{} 508.00m 252.00m
[root@server0 \PYGZti{}]\PYGZsh{} lvs
LV  VG      Attr    LSize   Pool Origin Data\PYGZpc{}       Move Log Cpy\PYGZpc{}Sync Convert
lvm1 vg1    \PYGZhy{}wi\PYGZhy{}ao\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} 256.00m
当前卷组中没有足够的容量给 lvm1 扩容，需要扩卷组容量。原卷组有 508M，新建一个 500M 分区，加入到该卷组中。
[root@server0 \PYGZti{}]\PYGZsh{} fdisk /dev/vdb
Welcome to fdisk (util\PYGZhy{}linux 2.23.2).
Changes will remain in memory only, until you decide to write them. Be careful before using the write command.
Command (m for help): n
Partition type:
p   primary (1 primary, 0 extended, 3 free) e       extended
Select (default p):
Using default response p
Partition number (2\PYGZhy{}4, default 2):
First sector (1050624\PYGZhy{}20971519, default 1050624):
Using default value 1050624
Last sector, +sectors or +size\PYGZob{}K,M,G\PYGZcb{} (1050624\PYGZhy{}20971519, default 20971519): +500M
Partition 2 of type Linux and of size 500 MiB is set
Command (m for help): t
Partition number (1\PYGZhy{}3, default 3): 2
Hex code (type L to list all codes): 8e
Changed type of partition \PYGZsq{}Linux\PYGZsq{} to \PYGZsq{}Linux LVM\PYGZsq{}
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re\PYGZhy{}read partition table.
WARNING: Re\PYGZhy{}reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks.
[root@server0 \PYGZti{}]\PYGZsh{} partprobe
[root@server0 \PYGZti{}]\PYGZsh{} vgextend vg1 /dev/vdb2
Physical volume \PYGZdq{}/dev/vdb2\PYGZdq{} successfully created
Volume group \PYGZdq{}vg1\PYGZdq{} successfully extended
[root@server0 \PYGZti{}]\PYGZsh{} lvextend \PYGZhy{}r \PYGZhy{}L 770M /dev/vg1/lvm1
Rounding size to boundary between physical extents: 772.00 MiB
Extending logical volume lvm1 to 772.00 MiB
Logical volume lvm1 successfully resized meta\PYGZhy{}data=/dev/mapper/vg1\PYGZhy{}lvm1     isize=256       agcount=4, agsize=16384 blks
    =       sectsz=512      attr=2, projid32bit=1
    =       crc=0
data        =       bsize=4096      blocks=65536, imaxpct=25
    =       sunit=0 swidth=0 blks
naming      =version 2      bsize=4096      ascii\PYGZhy{}ci=0 ftype=0 log  =internal       bsize=4096      blocks=853, version=2
=   sectsz=512      sunit=0 blks, lazy\PYGZhy{}count=1 realtime =none       extsz=4096      blocks=0, rtextents=0
data blocks changed from 65536 to 197632
[root@server0 \PYGZti{}]\PYGZsh{}
验证：
[root@server0 \PYGZti{}]\PYGZsh{} df \PYGZhy{}h
Filesystem  Size    Used Avail Use\PYGZpc{} Mounted on
/dev/vda1 10G 3.1G 7.0G 31\PYGZpc{} / devtmpfs 906M 0 906M 0\PYGZpc{} /dev tmpfs 921M 140K 921M 1\PYGZpc{} /dev/shm tmpfs   921M    17M     904M    2\PYGZpc{} /run tmpfs   921M    0       921M    0\PYGZpc{} /sys/fs/cgroup
/dev/mapper/vg1\PYGZhy{}lvm1        769M    14M     756M    2\PYGZpc{} /vg1/lvm1
\end{sphinxVerbatim}


\section{创建用户和用户组}
\label{\detokenize{rhcsa/rhcsa_7:id2}}
请按照以下要求创建用户、用户组：
\begin{enumerate}
\item {} 
新建一个名为 adminuser 的组，组 id 为 40000 新建一个名为 natasha 的用户，并将 adminuser 作为其附属组新建一个名为 harry 的用户，并将 adminuser 作为其附属组

\item {} 
新建一个名为 sarah 的用户，其不属于 adminuser 组，并将其 shell 设置为不可登陆 shell natasha、harry 和 sarah 三个用户的密码均设置为 glegunge

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} groupadd \PYGZhy{}g 40000 adminuser}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} useradd \PYGZhy{}G adminuser natasha}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} useradd \PYGZhy{}G adminuser harry}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} useradd \PYGZhy{}s /sbin/nologin sarah}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} echo glegunge \textbar{}passwd \PYGZhy{}\PYGZhy{}stdin natasha Changing password for user natasha. passwd: all authentication tokens updated successfully.}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} echo glegunge \textbar{}passwd \PYGZhy{}\PYGZhy{}stdin harry Changing password for user harry. passwd: all authentication tokens updated successfully.}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} echo glegunge \textbar{}passwd \PYGZhy{}\PYGZhy{}stdin sarah Changing password for user sarah.}
\PYG{n}{passwd}\PYG{p}{:} \PYG{n+nb}{all} \PYG{n}{authentication} \PYG{n}{tokens} \PYG{n}{updated} \PYG{n}{successfully}\PYG{o}{.}
\end{sphinxVerbatim}


\section{文件权限设定}
\label{\detokenize{rhcsa/rhcsa_7:id3}}
复制文件/etc/fstab 到/var/tmp 目录下，并按照以下要求配置/var/tmp/fstab 文件的权限:

该文件的所属人为 root

该文件的所属组为 root 该文件对任何人均没有执行权限用户 natasha 对该文件有读和写的权限用户 harry 对该文件既不能读也不能写所有其他用户（包括当前已有用户及未来创建的用户）对该文件都有读的权限解答：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[root@server0 \PYGZti{}]\PYGZsh{} cp /etc/fstab /var/tmp/
[root@server0 \PYGZti{}]\PYGZsh{} cd /var/tmp/
[root@server0 tmp]\PYGZsh{} ll fstab
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}. 1 root root 358 Apr     4 07:27 fstab
[root@server0 tmp]\PYGZsh{} setfacl \PYGZhy{}m u:natasha:rw fstab
[root@server0 tmp]\PYGZsh{} setfacl \PYGZhy{}m u:harry:\PYGZhy{} fstab
[root@server0 tmp]\PYGZsh{} setfacl \PYGZhy{}m o:r fstab
验证结果：
[root@server0 \PYGZti{}]\PYGZsh{} getfacl /var/tmp/fstab
\end{sphinxVerbatim}


\section{建立计划任务}
\label{\detokenize{rhcsa/rhcsa_7:id4}}
对 natasha 用户建立计划任务，要求在本地时间的每天 14：23 执行以下命令：/bin/echo
“rhcsa”

解答：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[root@server0 \PYGZti{}]\PYGZsh{} su \PYGZhy{} natasha
[natasha@server0 \PYGZti{}]\PYGZdl{} crontab \PYGZhy{}e 编辑临时文件插入如下条目：
23 14 * * * /bin/echo \PYGZdq{}rhcsa\PYGZdq{}
:wq 保存退出。
查看结果
[natasha@server0 \PYGZti{}]\PYGZdl{} crontab \PYGZhy{}l
23 14 * * * /bin/echo \PYGZdq{}rhcsa\PYGZdq{}
\end{sphinxVerbatim}


\section{文件特殊权限设定}
\label{\detokenize{rhcsa/rhcsa_7:id5}}
在/home 目录下创建名为 admins 的子目录，并按以下要求设置权限：
\#. /home/admins 的所属组为 adminuser
\#. 该目录对 adminuser 组的成员可读可执行可写，但对其他用户没有任何权限，但 root 不受限制
\#. 在/home/admins 目录下所创建的文件的所属组自动被设置为 adminuser

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} mkdir /home/admins}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} chgrp adminuser /home/admins}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} chmod 2770 /home/admins}
\end{sphinxVerbatim}


\section{升级系统内核}
\label{\detokenize{rhcsa/rhcsa_7:id6}}
请按下列要求更新系统的内核：

新内核的 RPM 包位于
\sphinxurl{http://content.example.com/rhel7.0/x86\_64/errata/Packages/}

系统重启后，默认以新内核启动系统，原始的内核将继续可用

在 foundation 上使用浏览 \sphinxurl{http://content.example.com/rhel7.0/x86\_64/errata/Packages/}, 找到文件，复制下载链接

在终端中使用 wget 下载文件。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} wget http://content.example.com/rhel7.0/x86\PYGZus{}64/errata/Packages/kernel\PYGZhy{}3.10.0\PYGZhy{}123.1.2.el7.x86\PYGZus{}64.rpm}
\end{sphinxVerbatim}

安装 kernel：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{localinstall} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{kernel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.10}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{123.1}\PYG{o}{.}\PYG{l+m+mf}{2.}\PYG{n}{el7}\PYG{o}{.}\PYG{n}{x86\PYGZus{}64}\PYG{o}{.}\PYG{n}{rpm} \PYG{c+c1}{\PYGZsh{}安装内核时间比较长，需要等待几分钟。}
\end{sphinxVerbatim}

验证：查看当前内核版本信息，重启后再查看内核版本信息。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} uname \PYGZhy{}r}
\PYG{l+m+mf}{3.10}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{123.}\PYG{n}{el7}\PYG{o}{.}\PYG{n}{x86\PYGZus{}64}
\end{sphinxVerbatim}


\section{配置ldap客户端}
\label{\detokenize{rhcsa/rhcsa_7:ldap}}
在 classroom.example.com 上已经部署了一台 LDAP 认证服务器，按以下要求将你的系统加入到该 LDAP 服务中，并使用 ldap 认证用户密码：

该 LDAP 认证服务的 Base DN 为：dc=example,dc=com 该 LDAP 认证服务的 LDAP Server 为：classroom.example.com

认证的会话连接需要使用 TLS 加密，加密所用证书请在此下载 \sphinxurl{http://classroom.example.com/pub/example-ca.crt}

上一次考试只给了 Base DN 和 ldap 服务器，ldap 服务器名填写题目中提到的主机名。

解答：

用户信息和验证信息全为 ldap

安装软件包

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} yum install \PYGZhy{}y sssd}
\end{sphinxVerbatim}

打开配置界面

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} authconfig\PYGZhy{}tui}
\end{sphinxVerbatim}

左侧选中 Use LDAP 和右侧选中 Use LDAP Authentication，然后 Next

选中 Use TLS 和填写 LDAP Server 和 Base DN，然后 Next

下载证书

将证书下载到目录/etc/openldap/cacerts/

新开一个终端下载证书

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} cd /etc/openldap/cacerts/}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{n}{cacerts}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} wget http://classroom.example.com/pub/example\PYGZhy{}ca.crt}
\end{sphinxVerbatim}

下载完成后，回来点击 Ok。如果在证书下载前按了 ok，那么需要将前面的配置恢复成默认，然后重新配置。用户信息为 ldap 和验证信息为 Kerberos

安装软件包

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{sssd} \PYG{n}{krb5}\PYG{o}{\PYGZhy{}}\PYG{n}{workstation}\PYG{o}{.}\PYG{n}{x86\PYGZus{}64}
\end{sphinxVerbatim}

打开配置界面

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{authconfig}\PYG{o}{\PYGZhy{}}\PYG{n}{tui}
\end{sphinxVerbatim}

选中 Use LDAP 和 Use Kerberos，然后 Next

选中 Use TLS 和填写 LDAP Server 和 Base DN，然后 Next

配置 Kerberos

下载证书
将证书下载到目录/etc/openldap/cacerts/

新开一个终端下载证书

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} cd /etc/openldap/cacerts/}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{n}{cacerts}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} wget http://classroom.example.com/pub/example\PYGZhy{}ca.crt}
\end{sphinxVerbatim}

下载完成后，回来点击 Ok。如果在证书下载前按了 ok，那么需要将前面的配置恢复成默认，然后重新配置。验证：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} getent passwd ldapuser0}
\end{sphinxVerbatim}


\section{配置 LDAP 用户家目录自动挂载}
\label{\detokenize{rhcsa/rhcsa_7:id7}}
请使用 LDAP 服务器上的用户 ldapuser0 登陆系统，并满足以下要求：
\begin{enumerate}
\item {} 
ldapuser0 用户的家目录路径为/home/guests/ldapuser0

\item {} 
ldapuser0 用户登陆后，家目录会自动挂载到 classroom.example.com 服务通过 nfs 服务到处的/home/guests/ldapuser0

\item {} 
客户端挂载使用 nfs 版本 3

\end{enumerate}

解答：

安装软件包：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} yum install \PYGZhy{}y autofs}
\end{sphinxVerbatim}

查看 ldapuser0 家目录位置为/home/guests/ldapuser0 和服务器共享的位置/home/guests

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[root@server0 \PYGZti{}]\PYGZsh{} getent passwd ldapuser0
ldapuser0:*:1700:1700:LDAPTest User 0:/home/guests/ldapuser0:/bin/bash
[root@server0 \PYGZti{}]\PYGZsh{} showmount \PYGZhy{}e classroom Export list for classroom:
/home/guests 172.25.0.0/255.255.0.0
准备目录
[root@server0 \PYGZti{}]\PYGZsh{} mkdir /home/guests
[root@server0 \PYGZti{}]\PYGZsh{} cd /etc/auto.master.d/
[root@server0 auto.master.d]\PYGZsh{} touch ldap.autofs
[root@server0 auto.master.d]\PYGZsh{} vim ldap.autofs
/home/guests        /etc/auto.ldap
:wq 保存退出
[root@server0 auto.master.d]\PYGZsh{} cd /etc
[root@server0 etc]\PYGZsh{} touch auto.ldap
[root@server0 etc]\PYGZsh{} vim auto.ldap
*   \PYGZhy{}rw,sync,v3     classroom.example.com:/home/guests/\PYGZam{}
:wq 保存退出
设置 autofs 开机启动，并启动 autofs 服务。
[root@server0 \PYGZti{}]\PYGZsh{} systemctl enable autofs.service
ln  \PYGZhy{}s      \PYGZsq{}/usr/lib/systemd/system/autofs.service\PYGZsq{} \PYGZsq{}/etc/systemd/system/multi\PYGZhy{}user.target.wants/autofs.service\PYGZsq{}
[root@server0 \PYGZti{}]\PYGZsh{} systemctl restart autofs.service
验证：
su \PYGZhy{} ldapuser0
\end{sphinxVerbatim}

本题如果自动挂载失败，可能是时间与服务器不一致到值得。可以先做 NTP 服务配置，再回来完成此题。如果还是不行，使用 date 命令手动设置时间。

先查看物理主机时间

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{date}
\end{sphinxVerbatim}

然后设置 server 时间，将物理主机完整时间拷贝过来，修改一下操作过程时间差。
\begin{quote}

{[}\sphinxhref{mailto:root@server0}{root@server0} \textasciitilde{}{]}\# date -s “Wed Mar 15 09:37:36 CST 2017”
\end{quote}


\section{时间同步}
\label{\detokenize{rhcsa/rhcsa_7:id8}}
使用 NTP 配置系统时间与服务器 classroom.example.com 同步，要求系统重启后依然生效。

解答：

使用 chrony 配置或者 ntp 配置，都可以得分。

确认 chrony 软件包已经安装

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n+nb}{list} \PYG{n}{chrony}
\end{sphinxVerbatim}

一般情况，系统会自动安装。如果没有安装执行 yum install -y chrony 安装。

编辑配置文件/etc/chrony.conf，将文件中 server 记录全部删除或者注释掉，添加如下内容：
server classroom.example.com iburst

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[root@server0 \PYGZti{}]\PYGZsh{} vim /etc/chrony.conf
server classroom.example.com iburst
:wq 保存退出。
\end{sphinxVerbatim}


\section{设置 chronyd 服务开机启动并重启服务}
\label{\detokenize{rhcsa/rhcsa_7:chronyd}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} systemctl enable chronyd}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} systemctl restart chronyd}
\end{sphinxVerbatim}

验证：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} chronyc sources \PYGZhy{}v}
\end{sphinxVerbatim}

利用 server 设定上层 NTP 服务器，格式如下：

server {[}IP or hostname{]} {[}prefer{]} perfer:表示优先级最高 burst ：当一个运程 NTP 服务器可用时，向它发送一系列的并发包进行检测。 iburst ：当一个运程 NTP 服务器不可用时，向它发送一系列的并发包进行检测。

ntp 和 chrony 服务有冲突，同时只能运行一个。我们的评分脚本是根据 chrony 评分的。


\section{打包文件}
\label{\detokenize{rhcsa/rhcsa_7:id9}}
请对 /etc/sysconfig 目录进行打包并用 gzip 压缩，生成的文件保存为/root/sysconfig.tar.gz

-j, \textendash{}bzip2 filter the archive through bzip2

-J, \textendash{}xz filter the archive through xz

-z, \textendash{}gzip filter the archive through gzip

解答：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} tar \PYGZhy{}cvzf     /root/sysconfig.tar.gz /etc/sysconfig 评分脚本按照 bz2 格式评分，/root/sysconfig.tar.bz2}
\end{sphinxVerbatim}


\section{创建用户}
\label{\detokenize{rhcsa/rhcsa_7:id10}}
请创建一个名为 alex 的用户，并满足以下要求：

用户 id 为 3456 密码为 glegunge

解答：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} useradd \PYGZhy{}u 3456 alex}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} echo glegunge\textbar{}passwd \PYGZhy{}\PYGZhy{}stdin alex}
\end{sphinxVerbatim}


\section{创建 swap 分区}
\label{\detokenize{rhcsa/rhcsa_7:swap}}
为系统新增加一个 swap 分区：新建的 swap 分区容量为 512MiB 重启系统后，新建的 swap 分区会自动激活不能删除或者修改原有的 swap 分区

解答：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[root@server0 \PYGZti{}]\PYGZsh{} fdisk /dev/vdb
Welcome to fdisk (util\PYGZhy{}linux 2.23.2).
Changes will remain in memory only, until you decide to write them. Be careful before using the write command.
Command (m for help): n
Partition type:
p   primary (2 primary, 0 extended, 2 free) e       extended
Select (default p):
Using default response p
Partition number (3,4, default 3):
First sector (2074624\PYGZhy{}20971519, default 2074624):
Using default value 2074624
Last sector, +sectors or +size\PYGZob{}K,M,G\PYGZcb{} (2074624\PYGZhy{}20971519, default 20971519): +512M
Partition 3 of type Linux and of size 512 MiB is set
Command (m for help): t
Partition number (1\PYGZhy{}3, default 3):
Hex code (type L to list all codes): 82
Changed type of partition \PYGZsq{}Linux\PYGZsq{} to \PYGZsq{}Linux swap / Solaris\PYGZsq{}
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re\PYGZhy{}read partition table.
WARNING: Re\PYGZhy{}reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks.
通知内核更新分区表
[root@server0 \PYGZti{}]\PYGZsh{} partprobe
格式化 swap 分区
[root@server0 \PYGZti{}]\PYGZsh{} mkswap /dev/vdb3
编辑/etc/fstab
[root@server0 \PYGZti{}]\PYGZsh{} vim /etc/fstab
UUID=3a433201\PYGZhy{}5c45\PYGZhy{}46e0\PYGZhy{}9c1f\PYGZhy{}b8f2e48de8eb   swap    swap    defaults
0 0
:wq 保存退出。
挂载
[root@server0 \PYGZti{}]\PYGZsh{} swapon /dev/vdb3
验证：
[root@server0 \PYGZti{}]\PYGZsh{} swapon \PYGZhy{}s
[root@server0 \PYGZti{}]\PYGZsh{} free
\end{sphinxVerbatim}


\section{查找文件}
\label{\detokenize{rhcsa/rhcsa_7:id11}}
请把系统上拥有者为 ira 用户的所有文件，并将其拷贝到/root/findfiles 目录中

解答：文件夹一定要先创建。

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} mkdir findfiles}
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} find / \PYGZhy{}user ira \PYGZhy{}exec cp \PYGZhy{}rpf \PYGZob{}\PYGZcb{} /root/findfiles/ \PYGZbs{};}
\end{sphinxVerbatim}


\section{过滤文件}
\label{\detokenize{rhcsa/rhcsa_7:id12}}
把/usr/share/dict/words 文件中所有包含 seismic 字符串的行找到，并将这些行按照原始文件中的顺序存放到/root/wordlist 中，/root/wordlist 文件不能包含空行

解答：

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{root}\PYG{n+nd}{@server0} \PYG{o}{\PYGZti{}}\PYG{p}{]}\PYG{c+c1}{\PYGZsh{} grep seismic /usr/share/dict/words \PYGZgt{} /root/wordlist}
\end{sphinxVerbatim}


\section{LVM}
\label{\detokenize{rhcsa/rhcsa_7:lvm}}
请按下列要求创建一个新的逻辑卷创建一个名为 exam 的卷组，卷组的 PE 尺寸为 16MiB 逻辑卷的名字为 lvm2,所属卷组为 exam,该逻辑卷由 8 个 PE 组成将新建的逻辑卷格式化为 xfs 文件系统，要求系统启动时，该逻辑卷能被自动挂载到
/exam/lvm2 目录
解答：准备分区，标记分区类型，通知内核更新分区表

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[root@server0 \PYGZti{}]\PYGZsh{} fdisk /dev/vdb
Welcome to fdisk (util\PYGZhy{}linux 2.23.2).
Changes will remain in memory only, until you decide to write them. Be careful before using the write command.
Command (m for help): n
Partition type:
p   primary (3 primary, 0 extended, 1 free) e       extended
Select (default e):
Using default response e
Selected partition 4
First sector (3123200\PYGZhy{}20971519, default 3123200):
Using default value 3123200
Last sector, +sectors or +size\PYGZob{}K,M,G\PYGZcb{} (3123200\PYGZhy{}20971519, default 20971519):
Using default value 20971519
Partition 4 of type Extended and of size 8.5 GiB is set
Command (m for help): n
All primary partitions are in use
Adding logical partition 5
First sector (3125248\PYGZhy{}20971519, default 3125248):
Using default value 3125248
Last sector, +sectors or +size\PYGZob{}K,M,G\PYGZcb{} (3125248\PYGZhy{}20971519, default 20971519): +500M
Partition 5 of type Linux and of size 500 MiB is set
Command (m for help): t
Partition number (1\PYGZhy{}5, default 5):
Hex code (type L to list all codes): 8e
Changed type of partition \PYGZsq{}Linux\PYGZsq{} to \PYGZsq{}Linux LVM\PYGZsq{}
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re\PYGZhy{}read partition table.
WARNING: Re\PYGZhy{}reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks.
[root@server0 \PYGZti{}]\PYGZsh{} partprobe
创建 pv，vg，lv
[root@server0 \PYGZti{}]\PYGZsh{} pvcreate /dev/vdb5
Physical volume \PYGZdq{}/dev/vdb3\PYGZdq{} successfully created
[root@server0 \PYGZti{}]\PYGZsh{} vgcreate \PYGZhy{}s 16M exam /dev/vdb5 Volume group \PYGZdq{}wgroup\PYGZdq{} successfully created
[root@server0 \PYGZti{}]\PYGZsh{} lvcreate \PYGZhy{}l 8 \PYGZhy{}n lvm2 exam
Logical volume \PYGZdq{}wshare\PYGZdq{} created
[root@server0 \PYGZti{}]\PYGZsh{}
格式化分区
[root@server0 \PYGZti{}]\PYGZsh{} mkfs.xfs  /dev/exam/lvm2
创建挂载点
[root@server0 \PYGZti{}]\PYGZsh{} mkdir /exam/lvm2
设置永久挂载，编辑/etc/fstab，添加如下内容：
[root@server0 \PYGZti{}]\PYGZsh{} vim /etc/fstab
/dev/exam/lvm2      /exam/lvm2      xfs     defaults        0 0
:wq 保存退出
验证：
[root@server0 \PYGZti{}]\PYGZsh{} mount \PYGZhy{}a
[root@server0 \PYGZti{}]\PYGZsh{} df \PYGZhy{}h
[root@server0 \PYGZti{}]\PYGZsh{} vgdisplay exam
[root@server0 \PYGZti{}]\PYGZsh{} lvdisplay /dev/exam/lvm2
\end{sphinxVerbatim}


\section{最后检查}
\label{\detokenize{rhcsa/rhcsa_7:id13}}
重启前检查一遍考试涉及到的服务是否设置开机启动，selinux 问题服务包涵：定时计划任务 crond，ntp 对时 chronyd，自动挂载 autofs

第一遍做完一定要重启，保证有充足的时间排错。不要到最后 5 分钟再重启系统。

扩文件系统分两步：扩逻辑卷和扩文件系统，也可以在 lvextend 时候使用-r 参数直接扩文件系统，ext4 和 xfs 都支持

ldap 题目使用 authconfig-tui 字符界面完成。


\section{成绩自检：}
\label{\detokenize{rhcsa/rhcsa_7:id14}}
server0： lab examrhcsa grade



\renewcommand{\indexname}{Index}
\printindex
\end{document}